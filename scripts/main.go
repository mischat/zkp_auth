package main

import (
	"flag"
	"fmt"
	"log"
	"math/big"

	"github.com/fxtlabs/primes"
	zkpautils "github.com/mischat/zkp_auth/utils"
)

// We are going to use this script to generate the public data we need
// To setup our ZKP Auth system
// To find suitable values for g, h, and q we need to perform the following steps:
// 1. pick a prime number p
// 2. find a prime number q that divides p-1 evenly
// 3. find a number r such that p = qr + 1
// 4. find two numbers g, h such that h^r mod p = 1 && g^r mod p = 1
// 5. g and h must have the same prime order
// 6. p, q, g, h are public variables and they pass our validation checks

// Note that the security of the protocol depends on the difficulty of computing discrete logarithms in the group generated by g. For this reason, it's important to choose a large prime number p and a large prime factor q.
// https://en.wikipedia.org/wiki/Schnorr_group
func main() {
	// Define command line flags
	pFlag := flag.Int("p", 24, "the maximum prime number to search for")
	flag.Parse()

	fmt.Println("Hello, this setup script should be used to calaculate the public variables for the ZKP Auth system")
	// Firstly let's get a prime number, and then we need to find a group.
	// Generate the prime numbers less than or equal to some number that is passed in
	ps := primes.Sieve(*pFlag)
	fmt.Printf("we have just found all primes up until: '%d'\n", ps)

	// Get the biggest one
	p := big.NewInt(int64(ps[len(ps)-1]))

	fmt.Printf("The prime number p is selected as: '%d'\n", p)

	// Here we use the Schnorr group theory https://en.wikipedia.org/wiki/Schnorr_group
	// to find a set of suitable values for g, h and q
	// given that we will start from a value for p, we need to find a q, h and g

	// Find a prime number q that divides p-1 evenly
	// such that p = qr + 1
	q := big.NewInt(0)
	r := new(big.Int)

	for r = big.NewInt(2); r.Cmp(p) <= 0; r.Add(r, big.NewInt(2)) {
		fmt.Printf("even number to divide by: '%d'\n", r)
		tmp := (new(big.Int).Div(new(big.Int).Sub(p, big.NewInt(1)), r))
		if tmp.ProbablyPrime(20) {
			fmt.Println(tmp, " is probably prime")
			q = tmp
			break
		} else {
			fmt.Println(tmp, " is not prime")
		}
	}

	// This shouldn't happen
	if q == big.NewInt(0) {
		log.Fatal("No prime number q found")
	}

	// Now we should have a valid q
	fmt.Printf("The prime number q is selected as: '%d' and we have r: '%d'\n", q, r)

	var generators []*big.Int
	// Now to try and generate a value for h and g that have the right order
	for h := big.NewInt(2); h.Cmp(p) < 0; h.Add(h, big.NewInt(1)) {
		g := new(big.Int).Exp(h, r, p)
		if g.Cmp(big.NewInt(1)) == 0 {
			continue
		} else {
			fmt.Printf("Found a generator of p and q: '%d'\n", g)
			generators = append(generators, g)
		}
		if len(generators) == 2 {
			break
		}
	}

	// Now we should have our two generators
	g := generators[0]
	h := generators[1]
	fmt.Printf("The generators are: g:'%d' h: '%d'\n", g, h)

	// I think that this sanity validation check is a good idea
	// It might all be implied here
	fmt.Printf("Now to sanity check the values p:'%d' q: '%d' g: '%d' h: '%d'\n", p, q, g, h)
	valid, err := zkpautils.ValidatePublicVariables(p, q, g, h)

	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Valid: %t\n", valid)
}
