package main

import (
	"flag"
	"fmt"
	"log"
	"math/big"

	"github.com/fxtlabs/primes"
	zkpautils "github.com/mischat/zkp_auth/utils"
)

// We are going to use this script to generate the public data we need
// To setup our ZKP Auth system
// To find suitable values for g, h, and q we need to perform the following steps:
// 1. pick a prime number p
// 2. find a prime number q that divides p-1 evenly
// 3. find a number r such that p = qr + 1
// 4. find two numbers g, h such that h^r mod p = 1 && g^r mod p = 1
// 5. g and h must have the same prime order
// 6. p, q, g, h are public variables and they pass our validation checks

// Note that the security of the protocol depends on the difficulty of computing discrete logarithms in the group generated by g. For this reason, it's important to choose a large prime number p and a large prime factor q.
// https://en.wikipedia.org/wiki/Schnorr_group
func main() {
	// Define command line flags
	pFlag := flag.Int("p", 20000, "the maximum prime number to search for")
	flag.Parse()

	fmt.Println("Hello, this setup script should be used to calaculate the public variables for the ZKP Auth system")
	// Firstly let's get a prime number, and then we need to find a group.
	// Generate the prime numbers less than or equal to some number that is passed in
	ps := primes.Sieve(*pFlag)
	fmt.Printf("we have just found all primes up until: '%d'\n", ps)

	// Get the biggest one
	p := big.NewInt(int64(ps[len(ps)-1]))

	fmt.Printf("The prime number p is selected as: '%d'\n", p)

	// Here we use the Schnorr group theory https://en.wikipedia.org/wiki/Schnorr_group
	// to find a set of suitable values for g, h and q
	// given that we will start from a value for p, we need to find a q, h and g

	// Find a prime number q that divides p-1 evenly
	// such that p = qr + 1
	r := new(big.Int)

	q := new(big.Int)

	allPrimes := []*big.Int{}
	allRs := []*big.Int{}
	for r = big.NewInt(2); r.Cmp(p) <= 0; r.Add(r, big.NewInt(2)) {
		tmp := (new(big.Int).Div(new(big.Int).Sub(p, big.NewInt(1)), r))
		if tmp.ProbablyPrime(100) {
			fmt.Println(tmp, " is probably prime")
			allPrimes = append(allPrimes, tmp)
			allRs = append(allRs, r)
		}
	}

	fmt.Println("All the primes we found: ", allPrimes)

	generator := new(big.Int)

	for prime := range allPrimes {
		fmt.Println("prime: ", allPrimes[prime])

		// Now we should have a valid q
		fmt.Printf("The prime number q is selected as: '%d' and we have r: '%d'\n", allPrimes[prime], allRs[prime])

		// Now to try and generate a value for h and g that have the right order
		for h := big.NewInt(2); h.Cmp(p) < 0; h.Add(h, big.NewInt(1)) {
			g := new(big.Int).Exp(h, allRs[prime], p)
			if g.Cmp(big.NewInt(1)) == 0 {
				continue
			} else {
				if new(big.Int).Exp(g, allPrimes[prime], p).Cmp(big.NewInt(1)) == 0 {
					fmt.Printf("Found a generator of p and q: '%d'\n", g)
					generator = g
					q = allPrimes[prime]
					break
				}
			}
		}
	}

	// Now we should have our generator
	g := generator
	fmt.Printf("The generators is: g:'%d'\n", g)

	group := []*big.Int{}
	for i := big.NewInt(1); i.Cmp(q) < 0; i.Add(i, big.NewInt(1)) {
		tmp := new(big.Int).Exp(g, i, p)
		group = append(group, tmp)
	}

	fmt.Println("The group is: ", group)
	// I think that this sanity validation check is a good idea
	// It might all be implied here
	fmt.Printf("Now to sanity check the values p:'%d' q: '%d' g: '%d' h: '%d'\n", p, q, group[0], group[1])
	valid, err := zkpautils.ValidatePublicVariables(p, q, group[0], group[1])

	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Valid: %t\n", valid)
}
