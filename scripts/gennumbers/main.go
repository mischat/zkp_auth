package main

import (
	"flag"
	"fmt"
	"log"
	"math/big"

	"github.com/fxtlabs/primes"
	zkpautils "github.com/mischat/zkp_auth/utils"
)

// We are going to use this script to generate the public data we need
// To setup our ZKP Auth system
// To find suitable values for g, h, and q we need to perform the following steps:
// 1. pick a prime number p
// 2. find a prime number q that divides p-1 evenly
//   a. that is find a number r such that p = qr + 1
// 3. Find a generator for the Schnorr group
// 4. Generate 20 numbers in the group
// 5. find two numbers g, h such that h^r mod p = 1 && g^r mod p = 1
// 6. g and h must have the same prime order
// 7. Validate these numbers; p, q, g, h are public variables and they pass our validation checks

// Note that the security of the protocol depends on the difficulty of computing discrete logarithms in the group generated by g. For this reason, it's important to choose a large prime number p and a large prime factor q.
// https://en.wikipedia.org/wiki/Schnorr_group
func main() {
	// Define command line flags
	pFlag := flag.Int("p", 20000, "the maximum prime number to search for")
	flag.Parse()

	fmt.Println("Hello, this setup script should be used to calaculate the public variables for the ZKP Auth system")
	// Firstly let's get a prime number, and then we need to find a group.
	// Generate the prime numbers less than or equal to some number that is passed in
	ps := primes.Sieve(*pFlag)
	fmt.Printf("we have just found all primes up until: '%d'\n", pFlag)

	// Get the biggest one
	p := big.NewInt(int64(ps[len(ps)-1]))

	fmt.Printf("The prime number p is selected as: '%d'\n", p)

	// Here we use the Schnorr group theory https://en.wikipedia.org/wiki/Schnorr_group
	// to find a set of suitable values for g, h and q
	// given that we will start from a value for p, we need to find a q, h and g

	// Find a prime number q that divides p-1 evenly
	// such that p = qr + 1
	pMinusOne := new(big.Int).Sub(p, big.NewInt(1))

	q := new(big.Int)

	allPrimes := []*big.Int{}
	allRs := []*big.Int{}

	for i := 0; i < len(ps)-1; i++ {
		pToCheck := big.NewInt(int64(ps[i]))

		// This check ensures that we don't end up with an error due to rounding ints
		divison := new(big.Float).Quo(new(big.Float).SetInt(pMinusOne), new(big.Float).SetInt(pToCheck))
		if divison.IsInt() {
			if new(big.Int).Mod(new(big.Int).Div(pMinusOne, pToCheck), big.NewInt(2)).Cmp(big.NewInt(0)) == 0 {
				fmt.Println("This one here is a prime number that divides p-1 evenly: ", pToCheck)
				allPrimes = append(allPrimes, pToCheck)
				allRs = append(allRs, new(big.Int).Div(pMinusOne, pToCheck))
			}
		}
	}

	fmt.Printf("We have found '%d' many primes\n", len(allPrimes))

	generator := new(big.Int)

	for prime := range allPrimes {
		// Now to try and generate a value for h and g that have the right order
		for h := big.NewInt(1); h.Cmp(p) < 0; h.Add(h, big.NewInt(1)) {
			g := new(big.Int).Exp(h, allRs[prime], p)
			if g.Cmp(big.NewInt(1)) == 0 {
				continue
			} else {
				if new(big.Int).Exp(g, allPrimes[prime], p).Cmp(big.NewInt(1)) == 0 {
					fmt.Printf("Found a generator of p and q: '%d'\n", g)
					generator = g
					q = allPrimes[prime]
					break
				}
			}
		}
	}

	// Now we should have our generator
	g := generator
	fmt.Printf("The generators is: g:'%d'\n", g)

	group := []*big.Int{}
	// Create a group of size 20 (as we don't really need more in the group)
	for i := big.NewInt(1); i.Cmp(big.NewInt(20)) < 0; i.Add(i, big.NewInt(1)) {
		tmp := new(big.Int).Exp(g, i, p)
		group = append(group, tmp)
	}

	fmt.Println("The group is: ", group)
	// I think that this sanity validation check is a good idea
	// It might all be implied here
	fmt.Printf("Now to sanity check the values p:'%d' q: '%d' g: '%d' h: '%d'\n", p, q, group[0], group[1])
	valid, err := zkpautils.ValidatePublicVariables(p, q, group[0], group[1])

	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Valid: %t\n", valid)
}
